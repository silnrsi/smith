== Fonts ==

Fonts form the heart of the build system, given that they are the most complex component type to create and work with.

The minimum attributes a font object needs are: `target` and `source`. For example, the following `wscript` file is about as simple as one can get:

----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf')
----

This short file does more than might be expected. First of all it copies the input file `myfont.ttf` to an output file `build/results/myfont.ttf`footnote:[We will use unix style `/` for path separators]. This copy may seem redundant, but it is necessary for the rest of the system to work, and not all source fonts are unmodified `.ttf` files. It will also add this font to the default package, allowing a windows installer to be created. If there are tests `.txt` files in a directory called `tests` then these can be run against this font.

Notice that an input and an output file may not have the same name. Even if the output file ends up in `build/` it still corresponds to a real input file that may or may not be in `build/`. So file paths must be unique if the files are unique.

What if the source isn't a `.ttf` file. We can simply change the above example to:

----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd')
----

and the system will automatically convert the fontforge source font to truetype as it is copied into the `build` results directory tree. Here we wouldn't actually need the `results/` prefix to the target because the filename isn't the same as the `source` attribute.

There are other attributes that modify a truetype font as it is processed:

version::
    This takes a version number in the form 'x'.'y' (a floating point number) and sets the output font to have that version.

=== OpenType ===

There are two ways of adding opentype information to a font. One is to already have it in the source font. This is the most common approach. We need to indicate to the font builder that we are working with an opentype font, even if everything is internal to the font. The font builder needs to know for font testing purposes or if the font is generated from a legacy font.

----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd',
     opentype = internal())
----

This will generate tests pertinant to opnetype testing. See the section on font tests.

One approach sometimes used for fontforge based projects is to keep all the lookups in one font and then to share these lookups across all the fonts in a project. For this we simply specify a `sfd_master` attribute and the font builder will use `sfdmeld` to integrate the lookups in the master into each font as it is built. There is no need to specify that the font is opentype in this case, because that is obvious from context:

----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd',
     sfd_master = 'mymaster.sfd')
----

Obviously, if the `sfd_master` attribute is the same as the `source` file then no merge occurs. This is an alternative way of specifying that the font is opentype.

Another approach to adding opentype tables to a font is to use an external tool to create the lookups in and then to have that compile them into the font. Currently, the only external tool supported by the system is Microsoft's Volt. This uses a command line volt compiler to integrate the `.vtp` source into the font. In addition, the `.vtp` source is autogenerated from a source and any other elements that go to make the final integrated source. For example we show a maximal `volt()` integration to show all the components and then discuss them.

Notice that while the initial parameter to such objects as `volt` is required, all named parameters are optional.

----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     opentype = volt('myfont.vtp',
                     master = 'mymaster.vtp'),
     ap = 'myfont.xml',
     classes = 'project_classes.xml')
----

We define the `.vtp` file to create for this font which will then be compiled into the font using `volt2ttf` as `myfont.vtp`. We also declare a shared master volt project that is shared between all the fonts (well at least this one!). In building a largely automated volt project, a program `make_volt` is used that can take attachment point information from an xml database `myfont.xml`. This may be augmented with class information using `project_classes.xml`. These two file references are within the font rather than the volt details because they are shared with other smart font technologies particularly graphite.

Other attributes used in the `volt()` object are:

make_params::
    These parameters are passed to the make_volt process. The value is a string of parameters.

params::
    These parameters are passed to volt2ttf to modify the compiling of the volt source into opentype tables.

=== Graphite ===

Adding graphite tables to a font is much like adding volt information. The relevant files are declared either to the font or a `gdl()` object. For example:

----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     graphite = gdl('myfont.gdl',
                     master = 'mymaster.gdl'),
     ap = 'myfont.xml',
     classes = 'project_classes.xml')
----

Notice that the `ap` and `classes` attributes have the same values and meaning as for OpenType tables. This is because the information is used in the creation of both sets of tables. The `myfont.gdl` is created by the `make_gdl` process and it pulls in `mymaster.gdl` during compilation.

Other attributes of the `gdl()` object are:

params::
    Parameters to pass to `grcompiler` to control the compilation of graphite source to graphite tables in the font.

=== Legacy Fonts ===

Many fonts are actually built from another font, either legacy encoded or generated from a source font or fonts. This can be achieved by giving a `legacy()` object as the `source` attribute for the font. For example, for a font generated from a legacy font using `ttfbuilder` we might do:

----
font(target = 'results/myfont.ttf',
     source = legacy('myfont_src.ttf',
                     source = 'my_legacyfont.ttf',
                     xml = 'legacy_encoding.xml',
                     ap = 'my_legacyfont.xml'))
----

The legacy object creates the source font that is then copied to the output and perhaps smarts are added too.



=== Licensing and Copyright ===

Fonts contain both copyright and license information. The `copyright` attribute is the copyright string for the font and if present that string will be inserted into the font as the copyright statement.

The license object is an object that describes how to generate the specific license for this font. It also allows the collecting of license information for all the fonts in a package. Currently, the only license type supported is the OFL. For example:

----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     copyright = 'Copyright me, all rights reserved',
     license = ofl('myfont', 'me',
                    version = 1.1,
                    copyright = 'Copyright me',
                    file = "myOFL.txt'))
----

The first parameter for the `ofl()` object is a reserved word. Multiple words may be given as the initial parameters. These all appear in the license statement as the reserved words for that license. All the reserved words in all the fonts in a package are collected into one list that is then put into the license for the package. The OFL version may be given and defaults to 1.1. The copyright message is put at the start of the license statement. If not specified the global variable COPYRIGHT is used for this. The file where the license ends up may be given but defaults to `OFL.txt`.


=== Tests ===

wsiwaf includes a powerful system for testing with the potential to add different types of font tests. Currently there is only one font test type and also by default a single font test object is created that is used by all fonts for which no tests attribute is given.

The `fonttest` object takes these attributes:

testdir::
    This gives the directory relative to which all test files are to be found in the source tree. If unspecified, the global variable TESTDIR is used to give a default value. If this isn't set then the `tests` dir is used. So if one had tests in a different directory the following would work:

----
TESTDIR = 'test-suite'
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf')
----

texts::
    This is a glob string or list of glob strings that describe the text files to use for testing. The default is `*.txt`. For each text file and each font a `.tex` file is created that references the text file, the font, the script and language. In addition tests are run for each smart font technology (`gr` and or `ot`). These files are then generated to pdf.

htexts::
    Creating text files for complex scripts when there is no keyboard and at the start of a development project, can be problematic. One approach is to simplify the entry of unicode codepoints through the use of a string in the text file of the form `\u`'xxxx' which is a unicode scalar identifier (including support for supplementary plane data). Such files (defaulting to `*.htxt` are preprocessed into the corresponding `*.txt` and added to the list of `texts` test files.

texs::
    The difference with these `.tex` files (defaulting to `*.tex`) is that they are treated as simply TeX files to be run through XeTeX for test purposes. This gives the user greater control over complex text runs than a simple text file can give.

test_suffix::
    The way a font is identified as part of a test result filename is based on the target file for that font. If a font has a `test_suffix` attribute then this is used instead for the font identifying name. 

