== Introduction ==

Smith is an extension to waf that is designed to create a build environment
for the creation of Writing System Implementations. Such implementations
are made up of a number of key elements: fonts, keyboards, sort orders.

=== Installation ===

Installing smith is simple. It consists of copying the smith file to a
suitable directory, usually the project directory where it can be shared within
any version control system. In addition a file `wscript` needs to be created
to control the build process. This wscript file is in fact a python program
but the way it is run is designed to hide that as much from the unsuspecting
user as possible. Thus only those who want to get into the programming aspects
need to.

In terms of necessary tools that smith makes use of, the details are listed
in the parts of documentation specific to the tools that get used.

=== Execution ===

The heart of the build system is the `wscript` file that controls the build
process. This is done by the python program creating a set of wsi component
objects. The system then takes these objects and allows the user to run various
build commands.

waf, on which smith is built, works by creating a build directory
into which all the results are stored. This leaves the source directories
pristine and makes for easy clearing up. The build directory is created using
the command:

----
smith configure
----

This process creates the build directory, checks that all the tools that smith
needs to achieve the build as described in `wscript` are available, and sets
up various internal environment variables. Thus if any changes are made to the
`wscript` that indicate what extra tools are needed, then the `configure` command needs
to be rerun.

After configuration it is possible to build the system. This is done using:

----
smith build
----

This creates the final release forms of the various components that are to be
built. For example, it will create any fonts or keyboards. But it does not
create any installers, these need another command:

----
smith exe
----

This creates the installers described by the various package objects. In turn
it also builds everything as specified by `smith build`.

----
smith pdfs
----

This creates font tests output as pdf.

----
smith fret
----

If the wscript has been set up to generate fret files, this will generate those files.

----
smith graide
----

This creates a subdirectory called graide that contains one .cfg file per font for use with graide.
If the font has no graphite smarts, no configuration file is created (for obvious reasons).

----
smith svg
----

This creates svg test results for fonts.

----
smith zip
----

Creates a zip appropriate for a source package.

----
smith clean
----

Removes the various files created by `smith build` in the build directory.

----
smith distclean
----

Removes the build directory completely.

=== Writing wscript ===

The `wscript` file is a python program, but the internal program environment is set up to minimise the amount of actual programming that needs to be done. There is no setup needed in the file, and object registration is automatic. It is possible to add waf specific extensions to the file and for details of this, users should read the waf manual.

The basic process of describing a build process is to create writing system component objects. These objects are `font()`, `kbd()` and `package()`. Specific details on what information each of these objects requires is given in the corresponding sections of this document. Likewise examples are given in the sections.

The build process is about creating files from other files. Most of these processes are internal to the object, but it is possible to do some advanced configuration allowing the `wscript` writer to take more control over the build process. The functions described here should be considered advanced, and the beginning authors should not need to concern themselves with them initially.

cmd(cmd, [input files], **options)::
    The `cmd()` function specifies are command to run as a string, then a list of dependent input files that are referenced via `${SRC}` in the command string. The target (which is given by the context of `cmd()` function is accessible via the `${TGT}` string. The first parameter to the function is the command string to execute, which is executed from the build directory. There are various options that can be added to a `cmd()`:

    late;;
        If set to non zero, this says that the command should be executed as late in the sequence of commands to be run on a file as possible.

    targets;;
        This is a list of extra targets that this command generates. So a single command can create more than one file.

    shell;;
        If set, says that the command should not be broken on spaces into elements to pass to an exec call, but to be passed through the shell for shell processing. Use this if you use file redirection, for example.

create()::
    The `create()` function takes an initial parameter of the filename of the file to be created. The next parameter is a command to create the specified file. Usually this is a `cmd()` function. For exasmple, consider a processing path on an input font:
+
[source,python]
----
source = create('xyz.sfd', cmd('myfirstprocess ${SRC} ${TGT}', ['infile.sfd']),
                           cmd('mysecondprocess ${DEP} ${TGT}'))
----

process()::
    This function does an in place modification of the first parameter file that is assumed to already exist. The remaining functions are used to process the file in place. Often this is a `cmd()` function, but some other file type specific functions do exist. For details of them, see the relevant component type section. To reference the temporary input file referenced, use `${DEP}`
+
[source,python]
----
target = process('outfile.ttf', cmd('ttfautohint ${DEP} ${TGT}'))
----
+
When `process()` is used on a source file, smith has to think a little harder.
smith works to a strict rule that no files are created or changed in the main
source tree. This means that smith cannot change a source file in its original
position. For similar reasons (which file should one read?), smith does not allow
there to be an identically named file with the same path in the source tree and
in the build tree. So we can't simply copy the source file into the build tree
and work on it there. Instead, smith creates a copy of the source file in the
buildtree by stripping its path component and storing it in the `tmp/`
directory. It then processes that in place. For the most part authors do not
have to consider this, and using `process()` on a source file will 'just work'.
But there are rare situations where knowledge of the underlying actions are
necessary.
+
Parameters for this function are:

    nochange;;
        If set, tells the system that there is no need to copy the dependency 
        file before running the task. This is an internal parameter that users
        are very unlikely to need to use.

test()::
    This function applies a process to its output file with no expected output, so any `cmd()` would only have a `${TGT}` in the string. Of course other dependent inputs may be used. This is used for running files through checking processes that can fail, and give reports.
    
getgit(format)::
    [TODO]
    This function assumes that the project is being managed by git. If not, then it returns an empty string. The function queries the git repository
    for the current commit revision sha. This is then formatted according to format (see python str.format) as the first parameter.
    In addition, the repository is queried to see if the current commit has been tagged, and therefore is probably
    a release version. If so, then the function returns the empty string. In addition if the command line option --release or -r is used after
    the smith subcommand, then this function will also return the empty string. 
    The resulting string is returned.

    Parameters for this function are:

        tagregexp;;
            Specifies the regexp to use to test if a particular tag on a commit is the kind of tag we consider a release.
            The default value is r'[vV]?[\d.]+'. If the regexp does not match or the match results in an empty string, then the tag is ignored.


