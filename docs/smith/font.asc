== Fonts ==

Fonts form the heart of the build system, given that they are the most complex component type to create and work with.

The minimum attributes a font object needs are: `target` and `source`. For example, the following `wscript` file is about as simple as one can get:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf')
----

This short file does more than might be expected. First of all it copies the input file `myfont.ttf` to an output file `build/results/myfont.ttf` footnote:[We will use unix style `/` for path separators]. This copy may seem redundant, but it is necessary for the rest of the system to work, and not all source fonts are unmodified `.ttf` files. It will also add this font to the default package, allowing a Windows installer to be created. If there are tests `.txt` files in a directory called `tests` then these can be run against this font.

Notice that an input and an output file may not have the same name. Even if the output file ends up in `build/` it still corresponds to a real input file that may or may not be in `build/`. So file paths must be unique if the files are unique.

What if the source isn't a `.ttf` file. We can simply change the above example to:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd')
----

and the system will automatically convert the FontForge source font to TrueType as it is copied into the `build` results directory tree. Here we wouldn't actually need the `results/` prefix to the target because the filename isn't the same as the `source` attribute.

The complete list of core attributes to a font are:

target::
    Output file for the generated font within `build`.

source::
    Basic design file used to generate the initial form of the output font.

params::
    Command line parameters passed to the program that converts the source font into the target font. This program changes depending on the source file format. For UFO it is psfufo2ttf.

version::
    This takes a version number in the form 'x'.'y' (a floating point number) and sets the output font to have that version. It may also be a tuple of the form (x.y, "text") where the text will be appended to the version string inside the font.
    If the tuple form is not used, then `getversion()` is called and if this returns something then that is prepended with "dev " to make a development sub version. If this is not wanted then use (x.y, "").

sfd_master::
    This attribute specifies a FontForge file that should be merged with the source FontForge file when creating the target. If the sfd_master file is the same as the source, then sfdmeld is not run.

ap::
    Attachment point database associated with the source font.

ap_params::
    Parameters passed to the program that creates the ap database from the source font.

classes::
    Classes .xml file that adds class information to the attachment point database before conversion into smart font source code.

copyright::
    Copyright string to insert into the font.

no_test::
    If set to True will not include the font in the font tests. This can be set after the font object is created.

package::
    Package object to insert this font into. If not specified the global package is used.

typetuner::
    Specifies that typetuner should be run on the target and to use the given file as the typetuner configuration xml file.


=== OpenType ===

There are two ways of adding OpenType information to a font. One is to already have it in the source font. This is the most common approach in FontForge based projects. We need to indicate to the font builder that we are working with an OpenType font, even if everything is internal to the font. The font builder needs to know for font testing purposes or if the font is generated from a legacy font.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd',
     opentype = internal())
----

This will generate tests pertinent to OpenType testing. See the section on font tests.

One approach sometimes used for FontForge based projects is to keep all the lookups in one font and then to share these lookups across all the fonts in a project. For this we simply specify a `sfd_master` attribute and the font builder will use `sfdmeld` to integrate the lookups in the master into each font as it is built.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd',
     sfd_master = 'mymaster.sfd')
----

Obviously, if the `sfd_master` attribute is the same as the `source` file then no merge occurs. This is an alternative way of specifying that the font is OpenType.

Another approach to adding OpenType tables to a font is to use an external tool or text file to create the lookups and then to have smith compile them into the font. Two formats for source files are supported: Microsoft's VOLT (Visual OpenType Layout Tool) and Adobe's Feature File.

==== VOLT ====

This approach uses a command line VOLT compiler to integrate the `.vtp` source into the font. In addition, the `.vtp` source is autogenerated from a source and any other elements that go to make the final integrated source. For example we show a maximal `volt()` integration to show all the components and then discuss them.

Notice that while the initial parameter to such objects as `volt` is required, all named parameters are optional.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     opentype = volt('myfont.vtp',
                     master = 'mymaster.vtp'),
     ap = 'myfont.xml',
     classes = 'project_classes.xml')
----

We define the `.vtp` file to create for this font which will then be compiled into the font using `volt2ttf` as `myfont.vtp`. We also declare a shared master volt project that is shared between all the fonts (well at least this one!). In building a largely automated volt project, a program `make_volt` is used that can take attachment point information from an xml database `myfont.xml`. This may be augmented with class information using `project_classes.xml`. These two file references are within the font rather than the volt details because they are shared with other smart font technologies particularly graphite.

The complete list of attributes to Volt() are:

master::
    The volt source that is processed against the font to generate the font specific volt to be compiled into the font.

make_params::
    These parameters are passed to the make_volt process. The value is a string of parameters.

params::
    These parameters are passed to volt2ttf to modify the compiling of the volt source into OpenType tables.

no_make::
    If this attribute is present, make_volt isn't run and the first parameter is assumed to be the specific .vtp for this font.

no_typetuner::
    The VOLT2TTF program used to compile the volt into opentype, also has the capability to emit an XML control file for typetuner. By default, if the font requests typetuner be run, the volt2ttf options will be set to generate this file. Setting this attribute stops this generation from happening and you will need to create the file some other way.

==== FEA ====

The Adobe Font Development Kit for OpenType (AFDKO) has defined a textual syntax for OpenType tables, called a feature file. smith handles .fea files by merging font-specific classes (built from the AP and classes files) with a provided master fea file, and the resulting font-specific fea file is then compiled into the font.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     opentype = fea('myfont.fea',
                    master = 'mymaster.fea'),
     ap = 'myfont.xml',
     classes = 'project_classes.xml')
----

The complete list of attributes to fea() follow those of other classes:

master::
    The fea source that will be merged with autogenerated classes to create the font-specific .fea file.

make_params::
    Extra parameters to pass to `psfmakefea`, the tool that is used to generate the font-specific .fea file.

no_make::
    If this attribute is present, then `psfmakefea` isn't run and the first parameter references a file that already exists rather than one that will be created by fea().

to_ufo::
    If this attribute is present and not false and also if the source file for the font ends in `.ufo`, the generated
    fea will be copied into the source .ufo as the features.fea file.

depends::
    A python list of additional source files on which the OpenType depends. Typically these are files mentioned via `include()` in the master fea file.

buildusingfontforge::
    If this attribute is present and not false, the FEA file will be compiled using FontForge instead of fonttools.

keep_feats::
    This boolean, used only when buildusingfontforge is true, tells fontforge to keep all the lookups associated with a given feature that are already in
    the font, and not wipe them when merging the feature file. For example, keeping the kern feature lookups, which
    are often best handled in a font design application rather than in fea files.

=== Graphite ===

Adding Graphite tables to a font is much like adding VOLT information. The relevant files are declared either to the font or a `gdl()` object. For example:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     graphite = gdl('myfont.gdl',
                     master = 'mymaster.gdl',
                     make_params = '-o "R C"'),
     ap = 'myfont.xml',
     classes = 'project_classes.xml')
----

Notice that the `ap` and `classes` attributes have the same values and meaning as for OpenType tables. This is because the information is used in the creation of both sets of tables. The `myfont.gdl` is created by the `make_gdl` process and it pulls in `mymaster.gdl` during compilation.

The complete list of attributes to a gdl() object are:

master::
    Non-font specific GDL that is #included into the font specific GDL.

make_params::
    Parameters passed to `make_gdl`.

params::
    Parameters to pass to `grcompiler` to control the compilation of Graphite source to Graphite tables in the font.

no_make::
    If this attribute is present, `make_gdl` is not run and the first parameter is assumed to be the gdl for the specific font.

depends::
    A python list of additional source files on which the GDL depends. Typically these are files mentioned via `#include` in the master GDL file.


=== Legacy Fonts ===

Many fonts are actually built from another font, either legacy encoded or generated from a source font or fonts. This can be achieved by giving a `legacy()` object as the `source` attribute for the font. For example, for a font generated from a legacy font using `ttfbuilder` we might do:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = legacy('myfont_src.ttf',
                     source = 'my_legacyfont.ttf',
                     xml = 'legacy_encoding.xml',
                     params = '-f ../roman_font.ttf',
                     ap = 'my_legacyfont.xml'))
----

The legacy object creates the source font that is then copied to the output and perhaps smarts are added too.

The complete set of attributes to a `legacy()` object is:

source::
    The legacy source font (`.ttf`) to use to convert to the Unicode source font.

xml::
    ttfbuilder configuration xml file to use for the conversion

params::
    Command line arguments to ttfbuilder. Note that files specified here need `../` prepended to them.

ap::
    Attachment point database of the legacy font that will be converted to the font.ap attribute file.

noap::
    Instructs the legacy converter not to create the ap database specified in the font. This would
    get used when another process, after legacy conversion, modifies the font and then you want the
    build system to autogenerate the ap database from that modified font rather than from the
    legacy font conversion process.

=== Licensing and Copyright ===

Fonts contain both copyright and license information. The `copyright` attribute is the copyright string for the font and if present that string will be inserted into the font as the copyright statement.

The license object is an object that describes how to generate the specific license for this font. It also allows the collecting of license information for all the fonts in a package. Currently, the only license type supported is the OFL. For example:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     copyright = 'Copyright 2012, Acme <email|URL>',
     license = ofl('myfont', 'Acme',
                    version = 1.1,
                    copyright = 'Copyright 2012, Acme Labs <email|URL>',
                    file = "OFL.txt'))
----

The first parameter for the `ofl()` object is the list of Reserved Font Names (RFN). There may be more than one RFN. (For more details about the RFN mechanism please refer to the OFL FAQ: http://scripts.sil.org/OFL). These all appear in the license statement as the reserved font names for that particular version of the font project. In this example the name of the font and the name of the company of the author are reserved so that any derivative must be distinct from these two names. This is designed to allow all changes to the font but to prevent collision of fonts with different features but the same names. The goal is to reduce confusion for both font authors and font users. All the reserved font names in all the fonts in a package - various other authors can indicate their own reserved font names - are collected into one list that is then put into the license for the package. The OFL version may be given and defaults to 1.1. The copyright message is put at the start of the license statement. If not specified the global variable COPYRIGHT is used for this. The file where the license ends up may be given but defaults to `OFL.txt`.

If the file parameter file exists then this file is simply copied into the font as the license.

=== WOFF ===

The WOFF format is a different file format based on TTF. Smith can generate .woff files. For example:

The `woff` object takes these attributes (which could well grow):

params::
    This string is passed as the command line options to the ttf2woff command.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     woff = woff('results/myfont.woff'))
----

=== Fret ===

Fret is a font reporting tool that generates a PDF report from a font file, giving information about all the glyphs in the font.

The `fret` object takes these attributes:

params::
    A parameter list to pass to fret. If not specified, then fret is run with the `-r` command line argument.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     fret = fret('results/myfont.pdf', params='-r -o i'))
----

=== DesignSpace ===

An alternative to the `font` object is the `designspace` object. A designspace specification normally defines a family of related fonts, and therefore the designspace object typically results in a number of fonts being generated -- in essence the designspace object creates multiple font objects. Most of the attributes of a font object also apply to a designspace object, the differences are described below.

Instead of a `source` attribute, the designspace object uses a
https://github.com/fonttools/fonttools/tree/master/Doc/source/designspaceLib#document-xml-structure[designspace] file. Each instance described in the designspace file is treated as a source, and the designspace object iterates over all these instances and builds output from each.

Thus the minimum needed for the designspace object is a designspace file and `target` attribute:

[source,python]
----
designspace('source/myfont.designspace',
    target = '${DS:FILENAME_BASE}.ttf')
----

Except for `source` and `sfd_master`, all other attributes of the font object can be used with the designspace object. Additionally the following attribute can be used:

params::
    Command line arguments to `psfcreateinstances`. A common usage is to provide unique logfile for each instance.

Note, however, that in contrast to the simplest font object, the `target` attribute cannot be as simple as `myfont.ttf` but must be an expression that yields an appropriate filename for each instance. This will also be true for some other attributes as well, for example the attachment point information specified by the `ap` attribute will need to be different for each instance.

To facilitate this, the designspace object provides a number of variables whose value is based on the particular instance being processed. To prevent possible name conflicts, the designspace object uses a `DS:` prefix for each of the variables it provides.

For a given instance, each attribute and each location introduce one or more variables. Consider the following instance definition:

[source,xml]
----
<instance
    familyname="MyFont"
    stylename="Bold"
    name="ACME MyFont Bold"
    filename="instances/myfont-bold.ufo"
    >
    <location>
        <dimension name="weight" xvalue="700" />
        <dimension name="width"  xvalue="100" />
        <dimension name="custom" xvalue="0" />
    </location>
    <info />
    <kerning />
</instance>

----

Based on the corresponding instance attributes, the following variables will be defined:

[options="header",width="80%",cols="2,4"]
|=========================================
| variable           | string value
| `${DS:FAMILYNAME}` | `MyFont`
| `${DS:STYLENAME}`  | `Bold`
| `${DS:NAME}`       | `ACME MyFont Bold`
| `${DS:FILENAME}`   | `instances/myfont-bold.ufo`
|=========================================

Additionally, for each of the above, two additional variables are defined. Adding `&#95;DASH` to the variable name results in a value where all spaces are replaced with a hyphen, while adding  `&#95;BASE` to the variable name results in a value which is the basename (without the extension) of the original value. For example:

[width="80%",cols="2,4"]
|=========================================
| `${DS:NAME_DASH}`     | `ACME-MyFont-Bold`
| `${DS:FILENAME_BASE}` | `myfont-bold`
|=========================================

Based on the location specified for the instance, the following variables are defined:

[width="80%",cols="2,4"]
|=========================================
| `${DS:AXIS_WEIGHT}` | `700`
| `${DS:AXIS_WIDTH}`  | `100`
| `${DS:AXIS_CUSTOM}` | `0`
|=========================================

One additional variable provides the path from the build directory to the instance UFO, which for our example would be:

[width="80%",cols="2,4"]
|=========================================
| `${DS:FILE}` | `source/instances/myfont-bold.ufo`
|=========================================
