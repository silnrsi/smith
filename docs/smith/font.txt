== Fonts ==

Fonts form the heart of the build system, given that they are the most complex component type to create and work with.

The minimum attributes a font object needs are: `target` and `source`. For example, the following `wscript` file is about as simple as one can get:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf')
----

This short file does more than might be expected. First of all it copies the input file `myfont.ttf` to an output file `build/results/myfont.ttf` footnote:[We will use unix style `/` for path separators]. This copy may seem redundant, but it is necessary for the rest of the system to work, and not all source fonts are unmodified `.ttf` files. It will also add this font to the default package, allowing a Windows installer to be created. If there are tests `.txt` files in a directory called `tests` then these can be run against this font.

Notice that an input and an output file may not have the same name. Even if the output file ends up in `build/` it still corresponds to a real input file that may or may not be in `build/`. So file paths must be unique if the files are unique.

What if the source isn't a `.ttf` file. We can simply change the above example to:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd')
----

and the system will automatically convert the FontForge source font to TrueType as it is copied into the `build` results directory tree. Here we wouldn't actually need the `results/` prefix to the target because the filename isn't the same as the `source` attribute.

The complete list of core attributes to a font are:

target::
    Output file for the generated font within `build`.

source::
    Basic design file used to generate the initial form of the output font.

version::
    This takes a version number in the form 'x'.'y' (a floating point number) and sets the output font to have that version. It may also be a tuple of the form (x.y, "text") where the text will be appended to the version string inside the font.

sfd_master::
    This attribute specifies a FontForge file that should be merged with the source FontForge file when creating the target. If the sfd_master file is the same as the source, then sfdmeld is not run.

ap::
    Attachment point database associated with the source font.

classes::
    Classes .xml file that adds class information to the attachment point database before conversion into smart font source code.

copyright::
    Copyright string to insert into the font.

tests::
    Test object to use for test generation. If not specified, the global font test object is used.

package::
    Package object to insert this font into. If not specified the global package is used.

typetuner::
    Specifies that typetuner should be run on the target and to use the given file as the typetuner configuration xml file.


=== OpenType ===

There are two ways of adding OpenType information to a font. One is to already have it in the source font. This is the most common approach. We need to indicate to the font builder that we are working with an OpenType font, even if everything is internal to the font. The font builder needs to know for font testing purposes or if the font is generated from a legacy font.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd',
     opentype = internal())
----

This will generate tests pertinent to OpenType testing. See the section on font tests.

One approach sometimes used for FontForge based projects is to keep all the lookups in one font and then to share these lookups across all the fonts in a project. For this we simply specify a `sfd_master` attribute and the font builder will use `sfdmeld` to integrate the lookups in the master into each font as it is built. There is no need to specify that the font is OpenType in this case, because that is obvious from the context:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.sfd',
     sfd_master = 'mymaster.sfd')
----

Obviously, if the `sfd_master` attribute is the same as the `source` file then no merge occurs. This is an alternative way of specifying that the font is OpenType.

Another approach to adding OpenType tables to a font is to use an external tool to create the lookups in and then to have that compile them into the font. Currently, the only external tool supported by the system is Microsoft's VOLT (Visual OpenType Layout Tool). This uses a command line VOLT compiler to integrate the `.vtp` source into the font. In addition, the `.vtp` source is autogenerated from a source and any other elements that go to make the final integrated source. For example we show a maximal `volt()` integration to show all the components and then discuss them.

Notice that while the initial parameter to such objects as `volt` is required, all named parameters are optional.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     opentype = volt('myfont.vtp',
                     master = 'mymaster.vtp'),
     ap = 'myfont.xml',
     classes = 'project_classes.xml')
----

We define the `.vtp` file to create for this font which will then be compiled into the font using `volt2ttf` as `myfont.vtp`. We also declare a shared master volt project that is shared between all the fonts (well at least this one!). In building a largely automated volt project, a program `make_volt` is used that can take attachment point information from an xml database `myfont.xml`. This may be augmented with class information using `project_classes.xml`. These two file references are within the font rather than the volt details because they are shared with other smart font technologies particularly graphite.

The complete list of attributes to Volt() are:

master::
    The volt source that is processed against the font to generate the font specific volt to be compiled into the font.

make_params::
    These parameters are passed to the make_volt process. The value is a string of parameters.

params::
    These parameters are passed to volt2ttf to modify the compiling of the volt source into OpenType tables.

no_make::
    If this attribute is present, make_volt isn't run and the first parameter is assumed to be the specific .vtp for this font.

no_typetuner::
    The VOLT2TTF program used to compile the volt into opentype, also has the capability to emit an XML control file for typetuner. By default, if the font requests typetuner be run, the volt2ttf options will be set to generate this file. Setting this attribute stops this generation from happening and you will need to create the file some other way.

More recently a textual representation of OpenType has been developed by Adobe. The Adobe Font Development Kit for OpenType (AFDKO) has a textual syntax for OpenType lookups, called a feature file. smith can work with these .fea files. It works by creating a font specific .fea file containing key classes and also attachment lookups for all the attachment points in the font. These can then be referenced in the appropriate features. It is unlikely that anyone will not use a master fea file.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     opentype = fea('myfont.fea',
                    master = 'mymaster.fea'),
     ap = 'myfont.xml',
     classes = 'project_classes.xml')
----

The complete list of attributes to fea() follow those of other classes:

master::
    The fea source that will be included at the end of the autogenerated .fea file.

make_params::
    Extra parameters to pass to make_fea, the tool that is used to generate the dynamic .fea file.

keep_feats::
    This tells the feature processor to keep all the lookups associated with a given feature that are already in
    the font, and not wipe them when merging the feature file. For example, keeping the kern feature lookups, which
    are often best handled in a font design application rather than in fea files.

no_make::
    If this attribute is present, then make_fea isn't run and the first parameter references a file that already exists rather than one that will be created by fea().


=== Graphite ===

Adding Graphite tables to a font is much like adding VOLT information. The relevant files are declared either to the font or a `gdl()` object. For example:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     graphite = gdl('myfont.gdl',
                     master = 'mymaster.gdl',
                     make_params = '-o "R C"'),
     ap = 'myfont.xml',
     classes = 'project_classes.xml')
----

Notice that the `ap` and `classes` attributes have the same values and meaning as for OpenType tables. This is because the information is used in the creation of both sets of tables. The `myfont.gdl` is created by the `make_gdl` process and it pulls in `mymaster.gdl` during compilation.

The complete list of attributes to a gdl() object are:

master::
    Non-font specific GDL that is #included into the font specific GDL.

make_params::
    Parameters passed to `make_gdl`.

params::
    Parameters to pass to `grcompiler` to control the compilation of Graphite source to Graphite tables in the font.

no_make::
    If this attribute is present, make_gdl is not run and the first parameter is assumed to be the gdl for the specific font.

=== Legacy Fonts ===

Many fonts are actually built from another font, either legacy encoded or generated from a source font or fonts. This can be achieved by giving a `legacy()` object as the `source` attribute for the font. For example, for a font generated from a legacy font using `ttfbuilder` we might do:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = legacy('myfont_src.ttf',
                     source = 'my_legacyfont.ttf',
                     xml = 'legacy_encoding.xml',
                     params = '-f ../roman_font.ttf',
                     ap = 'my_legacyfont.xml'))
----

The legacy object creates the source font that is then copied to the output and perhaps smarts are added too.

The complete set of attributes to a `legacy()` object is:

source::
    The legacy source font (`.ttf`) to use to convert to the Unicode source font.

xml::
    ttfbuilder configuration xml file to use for the conversion

params::
    Command line arguments to ttfbuilder. Note that files specified here need `../` prepended to them.

ap::
    Attachment point database of the legacy font that will be converted to the font.ap attribute file.

noap::
    Instructs the legacy converter not to create the ap database specified in the font. This would
    get used when another process, after legacy conversion, modifies the font and then you want the
    build system to autogenerate the ap database from that modified font rather than from the
    legacy font conversion process.

=== Licensing and Copyright ===

Fonts contain both copyright and license information. The `copyright` attribute is the copyright string for the font and if present that string will be inserted into the font as the copyright statement.

The license object is an object that describes how to generate the specific license for this font. It also allows the collecting of license information for all the fonts in a package. Currently, the only license type supported is the OFL. For example:

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     copyright = 'Copyright 2012, Acme <email|URL>',
     license = ofl('myfont', 'Acme',
                    version = 1.1,
                    copyright = 'Copyright 2012, Acme Labs <email|URL>',
                    file = "OFL.txt'))
----

The first parameter for the `ofl()` object is the list of Reserved Font Names (RFN). There may be more than one RFN. (For more details about the RFN mechanism please refer to the OFL FAQ: http://scripts.sil.org/OFL). These all appear in the license statement as the reserved font names for that particular version of the font project. In this example the name of the font and the name of the company of the author are reserved so that any derivative must be distinct from these two names. This is designed to allow all changes to the font but to prevent collision of fonts with different features but the same names. The goal is to reduce confusion for both font authors and font users. All the reserved font names in all the fonts in a package - various other authors can indicate their own reserved font names - are collected into one list that is then put into the license for the package. The OFL version may be given and defaults to 1.1. The copyright message is put at the start of the license statement. If not specified the global variable COPYRIGHT is used for this. The file where the license ends up may be given but defaults to `OFL.txt`.

If the file parameter file exists then this file is simply copied into the font as the license.

=== WOFF ===

The WOFF format is a different file format based on TTF. Smith can generate .woff files. For example:

The `woff` object takes these attributes (which could well grow):

params::
    This string is passed as the command line options to the ttf2woff command.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     woff = woff('results/myfont.woff'))
----

=== Fret ===

Fret is a font reporting tool that generates a PDF report from a font file, giving information about all the glyphs in the font.

The `fret` object takes these attributes:

params::
    A parameter list to pass to fret. If not specified, then fret is run with the `-r` command line argument.

[source,python]
----
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     fret = fret('results/myfont.pdf', params='-r -o i'))
----

=== Tests ===

smith includes a powerful system for testing with the potential to add different types of font tests. Currently there is only one font test type and also by default a single font test object is created that is used by all fonts for which no tests attribute is given.

There are two attributes associated with a font declaration that are to do with testing:

test_suffix::
    The way a font is identified as part of a test result filename is based on the target file for that font. If a font has a `test_suffix` attribute then this is used instead for the font identifying name. 

tests::
    This is a fonttest object that describes the testing targets available for this font. If none is specified then a global shared default fonttest object. This default is described later.


The `fonttest` object takes these attributes:

testdir::
    This gives the directory relative to which all test files are to be found in the source tree. If unspecified, the global variable TESTDIR is used to give a default value. If this isn't set then the `tests` dir is used. So if one had tests in a different directory the following would work:

[source,python]
----
TESTDIR = 'test-suite'
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf')
----

resultsdir::
    This specifies the directory under the build directory into which test results are placed. It can be set globally via TESTRESULTSDIR and defaults to the same directory as testdir.

texts::
    This is a glob string or list of glob strings that describe the text files to use for testing. The default is `*.txt`. For each text file and each font a `.tex` file is created that references the text file, the font, the script and language. In addition tests are run for each smart font technology (`gr` and or `ot`). These files are then generated to pdf.

htexts::
    Creating text files for complex scripts when there is no keyboard and at the start of a development project, can be problematic. One approach is to simplify the entry of unicode codepoints through the use of a string in the text file of the form `\u`'xxxx' which is a unicode scalar identifier (including support for supplementary plane data). Such files (defaulting to `*.htxt` are preprocessed into the corresponding `*.txt` and added to the list of `texts` test files.

targets::
    While the test system is designed to have sensible defaults, it is possible to override what happens when a particular test target is specified. This dictionary contains a test object associated with each of the test targets: pdfs, svg, test.  The default test type for each target is pdfs : tex(), svg : svg(), test : tests().

extras::
    Often a project will want to add tests to the existing defaults, rather than overriding them. This parameter takes the same structure as a targets parameter but instructs the system to add the tests rather than replace the defaults with these.

In effect, the default behaviour for testing can be written entirely in wscript explicitly:

[source,python]
----
TESTDIR = 'test'
TESTRESULTSDIR = TESTDIR
globaltest = fonttest(targets = { 'pdfs' : tex(), 'svg' : svg(), 'test' : tests()},
                      texts = '*.txt',  # all these are defaults and can be omitted
                      htexts = '*.htxt'
                      testdir = TESTDIR,
                      resultsdir = TESTRESULTSDIR)
font(target = 'results/myfont.ttf',
     source = 'myfont.ttf',
     test_suffix = 'myfont',    # derived default
     tests = globaltest)
----


The various test target classes are described here with the various parameters to each.

==== tex ====

This class is used to generate PDF files from input test files. It takes the following parameters:

files::
    This lists the files, relative to the testsdir, that should be used as sources for this test. The list is held in a dictionary with the value being key value pairs either stored as a dict or as a string with the pairs separated by &, as in key=value&key2=value2. These key values are used to set feature values and language and script for the file being tested. Any keys and values my be included. Particular keys are:

    lang;;
        Specifies the language code to pass for rendering.

    script;;
        Specifies the script code to pass for rendering

texs::
    The difference with these `.tex` files (defaulting to `*.tex`) is that they are treated as simply TeX files to be run through XeTeX for test purposes. This gives the user greater control over complex text runs than a simple text file can give.

htexs::
    These files are parsed for Unicode expansions before being treated as files in the +texs+ list. Defaults to '*.htex'.

==== crossfont ====

This class creates a single PDF file from all the fonts, with a given string output in the font next to the font file name. It takes the following parameters:

text::
    The text string to be rendered in the font. If not included, it is taken from the global TESTSTRING, and failing that, is empty.

file::
    Filename base (i.e. no extension), including path relative to the testsdir, where the output should be generated. Defaults to CrossFont.

size::
    This is a number that specifies the font size in points. Defaults to the global TESTFONTSIZE (in points) and failing that to 12pt.

featstr::
    Specifies the feature string that should passed to XeTeX after the script information. Each feature is separated from the next by a colon. The language feature is called language, as in language=pal.

[source,python]
----
t = fonttest(extras = {
    'specimen' : crossfont( text = u'Lorem Ipsum - Unicode pangram - Iñtërnâtiônàlizætiøn ', name = "Specimen", size = 10, featstr = "liga"),
    })
----


==== waterfall ====

This class creates a PDF file for each font and technology consisting of a waterfall of a string at various point sizes. It takes the following parameters:

text::
    The text string to be rendered in the font. If not included, it is taken from the global TESTSTRING, and failing that, is empty.

waterfalldir::
    Subdirectory under the test results directory into which to put the .tex and resulting .pdf files. If not present, uses the global WATERFALLDIR.

waterfallsizes::
    This is a number that specifies the font size in points. Defaults to the global TESTFONTSIZE (in points) and failing that to 12pt.

sizefactor::
    This specifies a factor to multiply each size by to get the linespacing. It default to the global TESTLINESPACINGFACTOR and defaults to 1.2

featstr::
    Specifies the feature string that should passed to XeTeX after the script information. Each feature is separated from the next by a colon. The language feature is called language, as in language=pal.


==== svg ====

This class is used for the generation of comparative SVG html reports to compare ot and graphite renderings. It takes the following parameters:

files::
    This dictionary gives all the test files to use and the feature values to use for rendering the text. The values follow the format used in the tex() class.

html::
    The html file that should be output that contains the links to all the test results.

diff::
    Specifies whether difference files should be generated. This value is a boolean.

==== tests ====

This class is used for managing regression type tests. In fact it can be used for any kinds of tests, since it allows the user to specify whatever tests they want and the commands involved. The first parameter passed to a tests() class contains a dictionary of test types (subdirectory names under the testsdir), and the cmd() to execute for that test type. For example, the default test list if none is specified, is equivalent to:

[source,python]
----
{ 'regression' : cmd('cmptxtrender -k -e ${shaper} -s "${script}" -t ${SRC[1]}
                      -o ${TGT} ${fileinfo} ${fileinfo} ${SRC[0]} ${SRC[2]}', shell=1) }
----

There are also some keywords that get expanded in the command string:

lang::
    The language tag for the test, whether extracted from the first few characters of the test file or specified as a
    parameter on the file in the file list.

script::
    The script tag. This is either specified in the files dictionary or comes from the script parameter in the font being tested.

shaper::
    Is either `ot` or `gr`, specifying which type of shaping is to be done in the test.

fileinfo::
    This is the value of the `extra` key in the `files` parameter dictionary for the particular file being processed.

In addition, a tests() takes the following named parameters:

standards::
    This directory is where to find the base fonts against which regression comparisons take place

files::
    As per the tex() files parameter.

ext::
    The default file extension for the `${TGT}` is `.log`, this can be changed using this parameter. For example: `ext='.pdf'`

shapemap::
    This is a function that is called with the +shaper+ expansion and the result is used for that expansion instead.

coverage::
    This may take the following values: `fonts` indicates that the test is run once per font only.
    `shapers` indicates that the test is run once per shaper per font. In these cases there is no text file in the inputs.

