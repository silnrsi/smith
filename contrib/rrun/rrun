#!/bin/bash

function usage() {
    cat <<EOT
usage: rrun [ options ] cmd [args]

runs the command (with its args) by first rsyncing the current directory 
to a ramdisk (/dev/shm), running the cmd, and then rsyncing everything back.

Any options supplied are passed on to both calls to rsync, and can be any of:
        -v          increase verbosity; also displays ramdisk location
        -c          skip based on checksum, not mod-time & size
        -n          perform a trial run with no changes made
        -C          auto-ignore files in the same way CVS does
        -f RULE     add a file-filtering RULE
        -F          same as -f 'dir-merge /.rsync-filter'
                    repeated: -f '- .rsync-filter'
        -i          output a change-summary for all updates

See rsync manpage for more information about these options.

EOT
}

CACHE_ID=$(md5sum <<< "$PWD" | cut -d ' ' -f1)
CDIR="/dev/shm/rrun/$CACHE_ID"

# Accumulate specific options from command line to pass to rsync:
declare -a rsyncOpts
while getopts "f:vcnCFi" flag; do
  case $flag in
    f)
       rsyncOpts+=("-$flag" "$OPTARG")
       ;;
    [cnCFi])
       rsyncOpts+=("-$flag")
       ;;
    v)
       rsyncOpts+=("-$flag")
       echo "ramdisk location: ${CDIR}"
       ;;
    *)
       usage
       exit 1
       ;;
  esac
done

# Everything else is the command and its args to be run:
shift $((OPTIND-1))

# Issue usage message if nothing to do:
if [ $# -eq 0 ]; then
    usage
    exit 1
fi

mkdir -p $CDIR;
rsync -am "${rsyncOpts[@]}" --del ./ "$CDIR/"
unshare -rm /bin/sh << EOT
mount --bind "$CDIR" .
cd "$PWD"
$@
EOT
rsync -amu "${rsyncOpts[@]}" --del "$CDIR/" ./
